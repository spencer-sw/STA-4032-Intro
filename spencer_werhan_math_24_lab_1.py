# -*- coding: utf-8 -*-
"""Spencer Werhan Math_24_Lab_1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1rwsTCxkp0nTfD3P3BKr3KqBBn_5Icwtv

## Python Basics

### Calculator
"""

# Comments with hashtag, python ignores this

30.34321 + 9.12313 - 3.5567
# Simple addition and subtraction

2*2
# Simple multiplication

2**8
# Exponent operator

2**123
# Can be useful for bigger numbers that standard calculators cannot display

2**12345
# Can be useful for bigger numbers that standard calculators cannot display

"""(From Google) The python sys module provides functions and variables which are used to manipulate different parts of the Python Runtime Environment.
It lets us access system-specific parameters and functions.
import sys.

Putting hashtag (#) before words in Text cell creates drop down menu to hide cells below
"""

import sys
sys.set_int_max_str_digits(100000)
2**45678

# (From Google) The python sys module provides functions and variables which are used to manipulate different parts of the Python Runtime Environment.
#It lets us access system-specific parameters and functions. import sys.

8/4
# Simple division

8//4
# Floor division, removes decimals and only returns an integer

9//4

9//2

10//2

10.5//2

# (From google)
quotient = 7 // 3     # This is the integer division operator
print(quotient)
remainder = 7 % 3
print(remainder)

"""The modulus operator, sometimes also called the remainder operator or integer remainder operator works on integers (and integer expressions) and yields the remainder when the first operand is divided by the second. In Python, the modulus operator is a percent sign (%). The syntax is the same as for other operators.

In the above example, 7 divided by 3 is 2 when we use integer division and there is a remainder of 1 when we use the modulus operator.

The modulus operator turns out to be surprisingly useful. For example, you can check whether one number is divisible by anotherâ€”if x % y is zero, then x is divisible by y. Also, you can extract the right-most digit or digits from a number. For example, x % 10 yields the right-most digit of x (in base 10). Similarly x % 100 yields the last two digits.

Finally, returning to our time example, the remainder operator is extremely useful for doing conversions, say from seconds, to hours, minutes and seconds. If we start with a number of seconds, say 7684, the following program uses integer division and remainder to convert to an easier form. Step through it to be sure you understand how the division and remainder operators are being used to compute the correct values.
"""

8%12

13%12

22%12

24%12

24%13
# N % M - N divided by M and returns remainder

"""https://stackoverflow.com/questions/17524673/understanding-the-modulus-operator

### Variables
"""

apples = 5
# (=) sets whatever is left of it to the value of what is right of the operator

Apples = 6
# Capilization matters

i have apples = 1

now_i_have_apples = 1
# To assign something a value, all has to be one string of characters, no spaces

apples == Apples
# == is asking if left is equal to right
# returns true (1) if yes, returns false (0) if no

oranges = 8

total = apples + oranges      # Adds assigned variable

total                         # displays variable

apples**2
# Multiplication with assigned variables and numbers

cost_per_apple = 0.25

total_apple_costs = cost_per_apple * apples
# Multiplication first then assigned to variable

total_apple_costs

"""### Vectors

(From google)
NumPy is a Python library used for working with arrays. It also has functions for working in domain of linear algebra, fourier transform, and matrices.

Useful websites
https://www.w3schools.com/python/numpy/numpy_getting_started.asp
https://www.w3schools.com/python/numpy/numpy_intro.asp

(From google)

matplotlib.pyplot is a collection of functions that make matplotlib work like MATLAB. Each pyplot function makes some change to a figure: e.g., creates a figure ...

Useful website

https://www.w3schools.com/python/matplotlib_pyplot.asp
```
# This is formatted as code
import numpy as np
```
"""

pip --version
# Checks version of PIP installed, more useful for home comp

import numpy as np
import matplotlib.pyplot as plt

# import (something) as (something else) allows for the installed library to be called as (something else) when wanting to run

np.arange(10)

# Python starts at zero
# Single number in parentheses will provide integers

"""Python Programming illustrating

numpy.arange method

import numpy as np

Printing all numbers from 1 to
2 in steps of 0.1

print(np.arange(1, 2, 0.1))


The advantage of numpy.arange() over the normal in-built range() function is that it allows us to generate sequences of numbers that are not integers.

"""

np.arange(11)

(np.arange(1, 2, 0.1))

# But can set a range and desired increase

x = np.arange(10)

# Can use libraries in variables

x

y = 3 * x + 5

# Can use assigned variables that contain arrays in equations

y

# Displays array after math

# x = np.array([133,24,333,4,5,6])
# y = np.array([11,22,33,44,55,66])

x,y

# Displays x and y

"""### Plotting"""

plt.plot(x,y)

# plt.plot calling matplotlip.pyplot and plotting x and y arrays

plt.plot(x,y,'.')

# Instead of straight connected line, points plotted as dots
# Can use chatgpt and ask to modify code to display how want

plt.plot(x,y,'r.')

# r next to the . changes color

plt.plot(x,y,'b--')

import matplotlib.pyplot as plt

plt.plot(x,y)

x = np.linspace(0,5,10)

# Return evenly spaced numbers over a specified interval.

x

y = x**2

plt.plot(x,y)

plt.plot(x,y)
plt.title("New Graph of x**2");
plt.xlabel("x");
plt.ylabel("y");

"""Can add titles, axis labels, legends, and many other pieces of info to make graph more informative"""

plt.plot(x,y,label="x squared")
plt.title("Graph of x**2");
plt.xlabel("x");
plt.ylabel("y");
plt.legend()

x = np.linspace(0, 2, 100)

plt.plot(x, x, label='linear')
plt.plot(x, x**2, label='quadratic')
plt.plot(x, x**3, label='cubic')

# Plots 3 separate graphs, named after label=

plt.xlabel('x label')
plt.ylabel('y label')

# Plots labels for graph

plt.title("Simple Plot")

# Displays title for label

plt.legend()

# Displays legend

labels = 'Frogs', 'Dogs', 'Cats', 'Birds'
sizes = [15, 30, 40, 15]
explode = (0, 0.1, 0, 0)  # only "explode" the 2nd slice (i.e. 'Dogs')

fig1, ax1 = plt.subplots()
ax1.pie(sizes, explode=explode, labels=labels, autopct='%1.1f%%', shadow=True, startangle=90)
ax1.axis('equal')  # Equal aspect ratio ensures that pie is drawn as a circle.
plt.show()

import numpy as np
import matplotlib.pyplot as plt
t = np.arange(0.0, 2.0, 0.01)
s = np.sin(2*np.pi*t)

plt.plot(t, s)
plt.title(r'$\alpha_i > \beta_i$', fontsize=20)
plt.text(1, -0.6, r'$\sum_{i=0}^\infty x_i$', fontsize=20)          # Plot coordinates are based off np.arange x and y scales
plt.text(0.5, 0.6, r'$\mathcal{A}\mathrm{sin}(2 \omega t)$',fontsize=15)
plt.xlabel('time (s)')
plt.ylabel('volts (mV)')
plt.show()

"""Plot the following functions from $x = -10$ to $x = 10$

(Hint: np.sin, np.exp)

*italicized text*$y = 10x+7$

$y = -3x-12$

$y=\sin(x)$

$y=e^x$

$y=e^{-x^2}$
"""

import numpy as np
import matplotlib.pyplot as plt
t = np.arange(-10.0, 10.0, 0.1)
s = 10*t+7

plt.plot(t, s)
plt.title(r'$\alpha_i > \beta_i$', fontsize=20)
plt.text(1, -50, r'$\sum_{i=0}^\infty x_i$', fontsize=20)
plt.text(0.5, 0.6, r'$\mathcal{A}\mathrm{sin}(2 \omega t)$',fontsize=15)
plt.xlabel('time (s)')
plt.ylabel('volts (mV)')
plt.show()

# ChatGPT -> fix code to prevent text overlap

import numpy as np
import matplotlib.pyplot as plt

# Create an array 't' with values ranging from -10 to 10 with a step of 0.1
t = np.arange(-10.0, 10.0, 0.1)

# Define the function 's' as a linear function of 't'
s = 10 * t + 7

# Plot 't' against 's'
plt.plot(t, s)

# Set the title of the plot with a LaTeX formatted string
plt.title(r'$\alpha_i > \beta_i$', fontsize=20)

# Adjust the position of the summation text to avoid overlap
plt.text(-9, 20, r'$\sum_{i=0}^\infty x_i$', fontsize=20)  # Adjusted y-coordinate

# Add text to the plot at specified coordinates with LaTeX formatted string
plt.text(0.5, -20, r'$\mathcal{A}\mathrm{sin}(2 \omega t)$', fontsize=15)  # Adjusted y-coordinate

# Set the label for the x-axis
plt.xlabel('time (s)')

# Set the label for the y-axis
plt.ylabel('volts (mV)')

# Display the plot
plt.show()

import numpy as np
import matplotlib.pyplot as plt
t = np.arange(-10, 10, 0.01)
s = -3*t-12

plt.plot(t, s)
plt.title(r'$\alpha_i > \beta_i$', fontsize=20)
plt.text(-7.5, -20, r'$\sum_{i=0}^\infty x_i$', fontsize=20)
plt.text(0.5, 0.6, r'$\mathcal{A}\mathrm{sin}(2 \omega t)$',fontsize=15)
plt.xlabel('time (s)')
plt.ylabel('volts (mV)')
plt.show()

import numpy as np
import matplotlib.pyplot as plt
t = np.arange(-10, 10, 0.01)
s = np.sin(t)

plt.plot(t, s)
plt.title(r'$\alpha_i > \beta_i$', fontsize=20)
plt.text(0.25, -0.6, r'$\sum_{i=0}^\infty x_i$', fontsize=20)
plt.text(2.5, 0.8, r'$\mathcal{A}\mathrm{sin}(2 \omega t)$',fontsize=15)
plt.xlabel('time (s)')
plt.ylabel('volts (mV)')
plt.show()

import numpy as np
import matplotlib.pyplot as plt
t = np.arange(-10.0, 10.0, 0.01)
s = np.exp(t)

plt.plot(t, s)
plt.title(r'$\alpha_i > \beta_i$', fontsize=20)
plt.text(1, 15000, r'$\sum_{i=0}^\infty x_i$', fontsize=20)
plt.text(0.5, 2500, r'$\mathcal{A}\mathrm{sin}(2 \omega t)$',fontsize=15)
plt.xlabel('time (s)')
plt.ylabel('volts (mV)')
plt.show()

import numpy as np
import matplotlib.pyplot as plt
t = np.arange(-10.0, 10.0, 0.01)
s = np.exp(-t**2)

plt.plot(t, s)
plt.title(r'$\alpha_i > \beta_i$', fontsize=20)
plt.text(-7.5, 0.6, r'$\sum_{i=0}^\infty x_i$', fontsize=20)
plt.text(0.6, 0.9, r'$\mathcal{A}\mathrm{sin}(2 \omega t)$',fontsize=15)
plt.xlabel('time (s)')
plt.ylabel('volts (mV)')
plt.show()

"""Pick out a plot of your choice from [here](https://matplotlib.org/stable/gallery/index.html), copy the code to this notebook, run, and document to the best of your abilities."""

import matplotlib.pyplot as plt
import numpy as np

from matplotlib.colors import Normalize
from matplotlib.markers import MarkerStyle
from matplotlib.text import TextPath
from matplotlib.transforms import Affine2D

SUCCESS_SYMBOLS = [
    TextPath((0, 0), "â˜¹"),
    TextPath((0, 0), "ðŸ˜’"),
    TextPath((0, 0), "â˜º"),
]

N = 25
skills = np.random.uniform(5, 80, size=N) * 0.1 + 5
takeoff_angles = np.random.normal(0, 90, N)
thrusts = np.random.uniform(size=N)
successful = np.random.randint(0, 3, size=N)
positions = np.random.normal(size=(N, 2)) * 5
data = zip(skills, takeoff_angles, thrusts, successful, positions)

cmap = plt.colormaps["jet"]
fig, ax = plt.subplots()
fig.suptitle("Throwing success", size=14)
for skill, takeoff, thrust, mood, pos in data:
    t = Affine2D().scale(skill).rotate_deg(takeoff)
    m = MarkerStyle(SUCCESS_SYMBOLS[mood], transform=t)
    ax.plot(pos[0], pos[1], marker=m, color=cmap(thrust))


plt.show()

"""The following is the plot I chose from the website in the above link"""

import matplotlib.pyplot as plt
import numpy as np

import matplotlib

matplotlib.rcParams['font.size'] = 8.0

# Fixing random state for reproducibility
np.random.seed(19680801)


# create random data
data1 = np.random.random([6, 50])

# set different colors for each set of positions
colors1 = [f'C{i}' for i in range(6)]

# set different line properties for each set of positions
# note that some overlap
lineoffsets1 = [-15, -3, 1, 1.5, 6, 10]
linelengths1 = [5, 2, 1, 1, 3, 1.5]

fig, axs = plt.subplots(2, 2)

# create a horizontal plot
axs[0, 0].eventplot(data1, colors=colors1, lineoffsets=lineoffsets1,
                    linelengths=linelengths1)

# create a vertical plot
axs[1, 0].eventplot(data1, colors=colors1, lineoffsets=lineoffsets1,
                    linelengths=linelengths1, orientation='vertical')

# create another set of random data.
# the gamma distribution is only used for aesthetic purposes
data2 = np.random.gamma(4, size=[60, 50])

# use individual values for the parameters this time
# these values will be used for all data sets (except lineoffsets2, which
# sets the increment between each data set in this usage)
colors2 = 'black'
lineoffsets2 = 1
linelengths2 = 1

# create a horizontal plot
axs[0, 1].eventplot(data2, colors=colors2, lineoffsets=lineoffsets2,
                    linelengths=linelengths2)


# create a vertical plot
axs[1, 1].eventplot(data2, colors=colors2, lineoffsets=lineoffsets2,
                    linelengths=linelengths2, orientation='vertical')

plt.show()





"""### Graphics Output

from IPython.core.display import display, HTML

ChatGPT
The line of code you provided is used to import the display and HTML functions from the IPython.core.display module in the IPython interactive environment. These functions are often used to display HTML content within IPython notebooks or other IPython-based environments.

Here's a brief explanation of what each part of the code does:

from IPython.core.display: This part of the code specifies that you want to import something from the IPython.core.display module.

import display, HTML: Here, you are importing two specific functions, display and HTML, from the IPython.core.display module.

After running this import statement, you can use the display and HTML functions to display HTML content or other interactive elements in your IPython environment. For example, you can use them to embed HTML code or display interactive widgets.

User
what is IPython.core.display


ChatGPT
IPython.core.display is a module within the IPython (Interactive Python) ecosystem that provides functionality for displaying various types of content, such as text, HTML, images, audio, and more, within the IPython interactive environment. This module is commonly used in IPython notebooks, Jupyter notebooks, and other IPython-based environments to enhance the presentation of output and make it more interactive.

Some of the commonly used functions and classes from IPython.core.display include:

display(): This function allows you to display content, such as variables, objects, or HTML, in a visually appealing and interactive way.

HTML(): This class is used to display HTML content within the IPython environment. You can pass HTML code as a string to create and display HTML elements.

Image(): This class is used to display images within IPython notebooks. You can specify the image file's path or URL to display it.

Audio(): This class allows you to play audio files directly within the IPython environment. You can provide the audio file's path or URL to play it.

Video(): Similar to Audio(), this class is used for displaying videos within IPython notebooks. You can specify the video file's path or URL.

Math(): This class is used for rendering mathematical expressions using LaTeX notation within IPython notebooks.

Latex(): Another class for rendering LaTeX content within IPython notebooks.

By importing and using these functions and classes from IPython.core.display, you can create more interactive and visually engaging content within your IPython-based documents or environments. It's particularly useful for data visualization, presentations, and interactive demonstrations.
"""

from IPython.core.display import display, HTML

display(HTML('<h1>Hello World!</h1>'))

"""### Numpy - Numerical Python"""

# Impoorts numpy module and shortens call name to np

import numpy as np

# Generates a random number between 0 and 1

np.random.random()

# The first command generates a random number, the '>' sign checks if the generated number is greater than 5
# If it is, a return of true (1) occurs, and if not, a return of false (0) occurs

np.random.random() > 0.5;

# Can write multiple commands on one line if separated by semi-colon ;

r = np.random.random(); print(r); r >0.5

r

r > 0.5







"""The following cell of code defines a function called flip_coin

This function uses the above RNG method and incorporates the if-else statements that define that if the string following is true (1), the perform the line following in the if condition.

If it is not true (false or 0), the move on to the else statement

In this case, it generates a random number and returns heads if true, and tails if false
"""

def flip_coin():
    if np.random.random() > 0.5:
        print("Heads")
    else:
        print("Tails")

flip_coin()

np.random.randint(15,20)

# The code np.random.randint(15, 20) uses NumPy's random.randint() function to generate a random integer between 15 (inclusive) and 20 (exclusive).
# A random number will be generated in the range of 15-19

def coin():
  return np.random.randint(2)

  # Because python counting in arrays begins at 0, this will only return a 0 or 1

coin()

display(HTML('<img src="https://random-ize.com/coin-flip/us-quarter/us-quarter-front.jpg">'))

heads = 'https://random-ize.com/coin-flip/us-quarter/us-quarter-front.jpg'
tails = 'https://random-ize.com/coin-flip/us-quarter/us-quarter-back.jpg'

"""In the code you uploaded:

python
Copy code
display(HTML('<img src=' + img + '>'))
The + img + is used for string concatenation in Python. In this context:

'<' and '>' are string literals containing the angle brackets < and > that are part of the HTML <img> tag.
'src=' is a string literal representing the src attribute of the <img> tag in HTML.
img is a variable that contains the URL of the image you want to display.
The + operator is used to concatenate these string literals and the img variable together to construct a complete HTML string. It effectively combines these elements into a single string, where img is inserted into the string at the position where the image URL should be.

(+ img +) is what is the input to the function is, the plus signs add all the text together to create a correct string between the input and what display(HTML()) is  supposed to do.
"""

def show_img(img):
  display(HTML('<img src=' + img + '>'))

show_img(heads)

show_img(tails)

def flip_coin():

    if coin():
        show_img(heads)
    else:
        show_img(tails)

# Can combine functions. We defined coin() earlier to generate a 0 or a 1.
# Since 1 is true, this will cause show_img(heads) command to follow.
# If a 0 is returned from coin, then it is false and show_img(tails) will occur

flip_coin()

"""You are using a for loop to simulate flipping a coin five times. Inside the loop, the flip_coin() function is called during each iteration to print either "Heads" or "Tails" based on the outcome of a random coin flip.

Here's how this code works:

for i in range(5):: This line sets up a for loop that will iterate five times. The loop variable i is not used within the loop, so it's just a counter.

flip_coin(): Inside the loop, the flip_coin() function is called during each iteration. This function contains the logic to simulate a coin flip and print the result. Since it uses randomization, it will print either "Heads" or "Tails" with roughly equal probability during each iteration.

When you run this code, you will see the result of five simulated coin flips displayed in the output. Each time you call flip_coin(), it simulates a coin flip and prints the result, so you will get a sequence of "Heads" and "Tails" based on the random outcomes.
"""

for i in range(5):
    flip_coin()

# Causes the flip_coin function to run 5 times, with i being the counter each time the loop is ran





"""# Cards"""



card_url_head = "https://www.improvemagic.com/wp-content/uploads/2020/11/"
card_url_tail = ".png"

# Sets beginning and end of url for pictures of all cards in deck
# middle portion to be determined by random generated

suit = ['k','p','s','l'] #clubs,spades,hearts,diamonds
card = ['a','2','3','4','5','6','7','8','9','10','j','q','k']

# Assigns vector to be used as base to assign random numbers and create a card

i = np.random.randint(4)
j = np.random.randint(13)

# Generates random integers 0-3 and 0-12

i,j

# Displays the randomly generated integers

suit[i]

# The vector "suit" created earlier has "i" input
# The first space, k, is 0, so if 0 generated, club suit drawn

card[j]

# The vector "card" created earlier has "j" input
# The first space, a, is 0, so if 0 generated, ace card drawn

"""The function card_image is designed to convert a card number from 0 to 51 into its corresponding suit and rank in a standard deck of playing cards. Here's a step-by-step explanation of how the function works:

Function Definition:

python

Copy code


def card_image(card_number):
This line defines the function card_image with one parameter card_number. The card_number is expected to be an integer between 0 and 51, inclusive.

Calculating the Suit:

python

Copy code

i = card_number // 13
The deck is divided into four suits, each containing 13 cards (Ace through King). The // operator performs integer division. By dividing card_number by 13 and taking the integer part, we get a number from 0 to 3, which corresponds to the index of the suit in the suit array. For example, if card_number is anywhere from 0 to 12, i will be 0, indicating the first suit (clubs, in the corrected version).

Calculating the Rank:

python

Copy code

j = card_number % 13
The % operator finds the remainder when card_number is divided by 13. This remainder is also a number between 0 and 12, corresponding to the index of the card's rank in the card array. For example, a card_number of 14 would result in a remainder of 1, indicating the '2' card in the respective suit.

Returning the Suit and Rank:

python

Copy code

return suit[i] + card[j]
This line constructs a string that represents the card. It accesses the suit array at index i to get the suit, and the card array at index j to get the rank, then concatenates them. For instance, if i is 1 (spades) and j is 0 (ace), the function will return 'sa', indicating the Ace of Spades.

In summary, the function card_image maps a single integer (representing a card's position in a standard 52-card deck) to its corresponding suit and rank. This is useful for identifying cards in a deck when they are represented by a single integer.
"""

def card_image(card_number):

    i = card_number//13
    j = card_number%13

    return suit[i]+card[j]

14%13

card_image(3)

# 3//13 = 0 which will place in first array of i
# 3%13 -> 3/13 using fun math is 0 integer with a remainder of 3 since 3 cannot be fully divided into 13 to return a whole number
# 14 goes into 13 one whole time with a remainder of 1 (for reference) -> 14/13 = 1.0769...

3%13

img = card_url_head + card_image(3) + card_url_tail

# https://www.improvemagic.com/wp-content/uploads/2020/11/k4.png full url for 4 of clubs

img

# Returns what image is defined as, in this case a url

show_img(img)

# Displays the image

for i in range(52):
    img = card_url_head + card_image(i) + card_url_tail
    show_img(img)

# Loops 51 times, starting at 0. img and show_img for 0 through 51 to show every card in a standard deck

"""ChatGPT

Your code provides a good structure for initializing and managing a deck of cards, represented by numbers 0-51. Let's walk through it:

Function initialize_deck:
This function creates a list of numbers from 0 to 51, each representing a card in a standard deck. It then shuffles this list to randomize the order of the cards. The shuffled deck is returned.

Function draw_cards:
This function is designed to draw a specified number of cards from the deck, starting from a given index (top_index).

deck[top_index:top_index + num] slices the deck list to get the desired number of cards (num). By default, num is 5, but it can be changed when calling the function.
It returns two values: drawn_cards, which is a list of the cards drawn, and top_index + num, which is the new top index after the cards have been drawn. This new top index is used for the next draw.
Initializing and Shuffling the Deck:
You correctly initialize the deck by calling initialize_deck() and set top_index to 0. This means you are ready to start drawing from the top of the deck.

Your implementation is efficient and clear. You can use these functions to simulate drawing cards from a deck in various card games or simulations. For example, to draw the first hand of 5 cards, you would do:

python
Copy code
hand, top_index = draw_cards(deck, top_index)
This would give you the first 5 cards from the deck in hand and update top_index for the next draw.

User
how does top_index work in the function
ChatGPT
The top_index variable in the draw_cards function serves as a marker to indicate the current position in the deck from which cards should be drawn. Let's look at how it's used in the function:

Function Definition:

python
Copy code
def draw_cards(deck, top_index, num=5):
This function takes three arguments: deck, top_index, and num (with a default value of 5). deck is the list of cards, top_index is the current position for drawing cards, and num is the number of cards to draw.

Drawing Cards:

python
Copy code
drawn_cards = deck[top_index:top_index + num]
This line uses Python list slicing to draw num cards starting from top_index. For example, if top_index is 0 and num is 5, this line would extract the first five cards from the deck (i.e., deck[0:5]).

Updating top_index:

python
Copy code
return drawn_cards, top_index + num
After drawing cards, the function returns two values: the drawn_cards and the new top_index, which is the old top_index incremented by num. This update is crucial because it tracks where the next draw should start in the deck.

For example, let's say you have a full deck, and top_index is initially 0. If you draw 5 cards, top_index becomes 5. The next time you draw cards, you'll start from the 6th card in the deck (index 5, as indexes start from 0).

In practice, it works like this:

First Draw:
python
Copy code
hand, top_index = draw_cards(deck, 0)  # Draws first 5 cards, top_index becomes 5
Second Draw:
python
Copy code
next_hand, top_index = draw_cards(deck, top_index)  # Draws next 5 cards, starting from index 5
Each time you draw cards, top_index is updated to ensure that the next draw picks up right where the last one left off. This simulates the real-life action of drawing cards from the top of a deck and removing those cards from the top.

User
what do hand and next_hand signify and how to do they work
ChatGPT
In the context of the draw_cards function, hand and next_hand are variables used to store the cards drawn from the deck during different draws. Let's clarify how they work in your card drawing simulation:

First Draw (hand):
When you perform the first draw from the deck, you use the draw_cards function. The variable hand is used to store the cards that are drawn in this first instance. For example:

python
Copy code
hand, top_index = draw_cards(deck, 0)
Here, hand will contain the first 5 cards from the deck (since the default number of cards to draw is 5). The top_index is updated to indicate the position for the next draw. In this case, top_index becomes 5, as 5 cards have been drawn.

Second Draw (next_hand):
For the second draw, you use the draw_cards function again, but this time starting from the updated top_index:

python
Copy code
next_hand, top_index = draw_cards(deck, top_index)
Now, next_hand will contain the next set of 5 cards from the deck, starting from where the first draw left off (i.e., starting from the 6th card in the deck). The top_index is again updated, this time to 10, to reflect the new position for any subsequent draws.

In a card game simulation, these variables (hand, next_hand, etc.) can represent the cards held by different players or the cards drawn in different rounds of the game. Each time you call draw_cards, you simulate drawing a new set of cards from the deck, and the deck gets progressively smaller as cards are "removed" from it (simulated by advancing the top_index).

It's important to note that the deck list itself is not modified; no cards are actually removed. The top_index simply keeps track of where in the deck you are for the purposes of the simulation.
"""

import random

def initialize_deck():
    #Create and shuffle a deck of 52 cards represented by numbers 0-51.
    deck = list(range(52))
    random.shuffle(deck)
    return deck

def draw_cards(deck, top_index, num=5):   # draw_cards is not called until two lines down, top_index is stored as 0 at end of this line of code
    drawn_cards = deck[top_index:top_index + num]
    return drawn_cards, top_index + num

# Initialize and shuffle the deck
deck = initialize_deck()
top_index = 0  # Start at the beginning of the deck

deck

"""ndex, 5)
ChatGPT
Your statement correctly draws 5 cards from the deck for a poker hand using the draw_cards function. Here's a breakdown of what the statement does:

hand, top_index = draw_cards(deck, top_index, 5):
draw_cards(deck, top_index, 5): This calls the draw_cards function with three arguments: deck (the shuffled deck of cards), top_index (the current starting position in the deck), and 5 (the number of cards to draw).
The function will return two values:
The first value, assigned to hand, is a list of 5 cards drawn from the deck starting at top_index.
The second value, which updates top_index, indicates the new position in the deck after drawing these cards.
After this statement, hand will contain the first poker hand of 5 cards, and top_index will be updated to reflect the next position in the deck for future draws.

If you want to see the actual cards represented by these numbers, you would use the card_image function on each number in the hand list to convert these numbers to their corresponding suit and rank representations. For example:

python
Copy code
hand_images = [card_image(card_number) for card_number in hand]
This would give you a list of string representations (like 'c3' for the Three of Clubs or 'hj' for the Jack of Hearts) for the cards in your poker hand.

User
how does hand get a value stored
ChatGPT
The value stored in hand comes from the execution of the draw_cards function. Let's break down how hand gets its value:

Function Call:

python
Copy code
hand, top_index = draw_cards(deck, top_index, 5)
Here, you are calling the draw_cards function with three arguments:

deck: The shuffled deck of cards.
top_index: The current position in the deck from which to start drawing cards.
5: The number of cards to draw.
Inside draw_cards Function:
Within the draw_cards function, the following operations happen:

Drawing Cards: The function slices the deck list from top_index to top_index + 5, which means it takes five elements starting from the position indicated by top_index.
Returning Results: The function then returns two values:
The first value is the slice of the deck list representing the drawn cards.
The second value is the updated top_index, which is the original top_index plus the number of cards drawn (5 in this case).
Assigning Values:
The return values from draw_cards are then assigned to hand and top_index, respectively.

hand receives the list of drawn cards.
top_index is updated to reflect the new position for the next draw.
As a result, hand ends up storing the list of the first five cards from the position indicated by the initial top_index. This simulates drawing five cards from the deck.

For example, if top_index was 0 and the deck was in a standard ordered state (not shuffled), hand would contain [0, 1, 2, 3, 4], representing the first five cards of the deck. After the draw, top_index would be updated to 5, ready for the next draw.
"""

# Draw 5 cards for a poker hand
hand, top_index = draw_cards(deck, top_index, 5)

# hand, top_index =
    ##return drawn_cards, top_index + num
# In the draw_cards function, two values are returned
# drawn_cards are stored in hand because it is first in the (hand, top_index =)
# top_index is stored as top_index + 5 since it is second in the order
# The return command in draw_cards returns to be variables to be stored and is determined by what is left of the equals sign

hand

hand, top_index = draw_cards(deck, top_index, 5)

hand

# Display the hand
for card_number in hand:
    img_url = card_url_head + card_image(card_number) + card_url_tail
    show_img(img_url)

def show_hand(hand):
    images_html = ''.join([f'<img src="{card_url_head + card_image(card_number) + card_url_tail}" style="display:inline-block; margin:5px;" />' for card_number in hand])
    display(HTML(images_html))

show_hand(hand)





"""# Rank Hand"""

def evaluate_hand(hand):
    rank_values = {'2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, '10': 10, 'j': 11, 'q': 12, 'k': 13, 'a': 14}
    suits = ['k', 'p', 's', 'l']  # clubs, spades, hearts, diamonds

    # Convert the hand to a list of (rank, suit) tuples
    converted_hand = [(rank_values[card[card_number % 13]], suits[card_number // 13]) for card_number in hand]
    converted_hand.sort()

    rank_counts = {rank: 0 for rank in rank_values.values()}
    suit_counts = {suit: 0 for suit in suits}
    for rank, suit in converted_hand:
        rank_counts[rank] += 1
        suit_counts[suit] += 1

    # Check for flush
    is_flush = max(suit_counts.values()) == 5

    # Check for straight and royal flush
    rank_sequence = [rank for rank, _ in converted_hand]
    is_straight = all(rank_sequence[i] - rank_sequence[i - 1] == 1 for i in range(1, 5))
    is_royal = is_straight and rank_sequence[0] == 10

    # Check for other hand types
    pairs = sum(1 for count in rank_counts.values() if count == 2)
    three_of_a_kind = 3 in rank_counts.values()
    four_of_a_kind = 4 in rank_counts.values()

    if is_royal and is_flush:
        return "Royal Flush"
    elif is_straight and is_flush:
        return "Straight Flush"
    elif four_of_a_kind:
        return "Four of a Kind"
    elif three_of_a_kind and pairs == 1:
        return "Full House"
    elif is_flush:
        return "Flush"
    elif is_straight:
        return "Straight"
    elif three_of_a_kind:
        return "Three of a Kind"
    elif pairs == 2:
        return "Two Pair"
    elif pairs == 1:
        return "One Pair"
    else:
        return "High Card"



# Initialize and shuffle the deck
deck = initialize_deck()
top_index = 0  # Start at the beginning of the deck

hand, top_index = draw_cards(deck, top_index, 5)


print(evaluate_hand(hand))
show_hand(hand)



for i in range(10):
    # Initialize and shuffle the deck
    deck = initialize_deck()
    top_index = 0  # Start at the beginning of the deck

    hand, top_index = draw_cards(deck, top_index, 5)


    print(evaluate_hand(hand))
    show_hand(hand)



for i in range(100):
    # Initialize and shuffle the deck
    deck = initialize_deck()
    top_index = 0  # Start at the beginning of the deck

    hand, top_index = draw_cards(deck, top_index, 5)

    if evaluate_hand(hand) == "Two Pair":
        print("Winner!")
        show_hand(hand)



for i in range(1000):
    # Initialize and shuffle the deck
    deck = initialize_deck()
    top_index = 0  # Start at the beginning of the deck

    hand, top_index = draw_cards(deck, top_index, 5)

    if evaluate_hand(hand) == "Flush":
        print("Winner!")
        show_hand(hand)

# Commented out IPython magic to ensure Python compatibility.
# %%timeit
# # Initialize and shuffle the deck
# deck = initialize_deck()
# top_index = 0  # Start at the beginning of the deck
# 
# hand, top_index = draw_cards(deck, top_index, 5)
# 
# if evaluate_hand(hand) == "Royal Flush":
#     print("Winner!")
#     show_hand(hand)

for i in range(1000000):
    # Initialize and shuffle the deck
    deck = initialize_deck()
    top_index = 0  # Start at the beginning of the deck

    hand, top_index = draw_cards(deck, top_index, 5)

    if evaluate_hand(hand) == "Royal Flush":
        print("Winner!")
        show_hand(hand)



wins = 0
N = 10000000

for i in range(N):
    # Initialize and shuffle the deck
    deck = initialize_deck()
    top_index = 0  # Start at the beginning of the deck

    hand, top_index = draw_cards(deck, top_index, 5)

    if evaluate_hand(hand) == "Royal Flush":
        wins += 1
        print("Winner!")
        show_hand(hand)

wins/N


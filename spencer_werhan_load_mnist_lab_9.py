# -*- coding: utf-8 -*-
"""Spencer Werhan Load MNIST Lab 9.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Zqui2_pBDp_8FEAWkU0dKT3x07sdeLvR

## Intro

torch: This is the main PyTorch library, which is widely used for machine learning and deep learning applications.

torchvision: A package that includes datasets, model architectures, and common image transformations for computer vision.

numpy: A fundamental package for scientific computing in Python, often used for large, multi-dimensional arrays and matrices, along with a large collection of high-level mathematical functions to operate on these arrays.
"""

import torch
from torchvision import datasets, transforms
import numpy as np
# Define a transform to normalize the data
transform = transforms.Compose([transforms.ToTensor()])

    # Here, transforms.Compose is used to chain together several transformations.
    # The only transformation applied is transforms.ToTensor(), which converts a PIL
    # image or a NumPy array into a PyTorch tensor and scales the image's pixel intensity values from 0-255 to 0-1.

# Download and load the MNIST training data
train_data = datasets.MNIST(root='./data', train=True, download=True, transform=transform)

    # datasets.MNIST is used to download the MNIST dataset. The parameters specify where to store the data (root),
    # whether to download the training dataset (train=True), whether to download the dataset if it's not already available
    # locally (download=True), and the transformations to apply to each data item (transform=transform).

# Extracting the data and targets as tensors
train_images = train_data.data
train_labels = train_data.targets

train_images.shape, train_labels.shape

# The images and labels are extracted from train_data. The shapes of these tensors are printed out, showing the number of samples and their dimensions.
# train_images.shape should show something like (60000, 28, 28), indicating 60,000 images each of 28x28 pixels. train_labels.shape should show (60000,), indicating there are 60,000 labels.

"""This part of the script imports matplotlib.pyplot, a plotting library. It extracts the first image from train_images and displays it using plt.imshow(). Since x is a tensor, imshow can handle it and display the corresponding image, which should be a handwritten digit from the MNIST dataset."""

import matplotlib.pyplot as plt

28*28

train_images[0,:,:]

"""Selects the first image from train_images and displays it. This image is a 28x28 pixel grayscale image of a handwritten digit."""

x = train_images[0,:,:]

plt.imshow(x)

train_labels[0]

# Retrieves the label corresponding to the first image in train_images. This label is an integer representing the digit depicted in the image.

"""## Next few lines of code

x.shape prints the shape of x before and after various operations.

x.flatten() converts the 28x28 image into a 784-element 1D array (flattening the tensor).

After flattening and checking the shape, x is reshaped back to a 28x28 matrix to confirm the reshape operation works as expected.
"""

x.shape

x.flatten()

x = x.flatten()

x.shape

x = x.reshape(28,28)

x.shape

"""## Next few lines of code

m is a randomly generated tensor with dimensions 10x784. It could represent weights of a neural network layer.

x is flattened again and normalized by dividing by 255, converting pixel values to a range [0,1].

m@x and torch.matmul(m, x) both perform matrix multiplication between m and x.

 The results, y, are a tensor with shape [10], which could represent the logits or outputs of a neural network layer for 10 classes.

torch.max(y) and torch.argmax(y) are used to find the maximum value in y and the index of this maximum value, respectively.
"""

m = torch.rand(10,784)

m

m.shape

x = x.flatten()

x = x/255.0

x

m.shape,x.shape

m@x

y = torch.matmul(m,x)

y

torch.max(y)

torch.argmax(y)

"""## Next few lines of code

This part processes a batch of 25 images. Each image is normalized, flattened, and reshaped.

x.T transposes the matrix x so it can be multiplied by m.

y = m@x computes the matrix product, resulting in a tensor y with shape [10, 25], which could represent the outputs for 10 classes across 25 examples.

plt.imshow(y) attempts to visualize these outputs as an image. However, because y contains arbitrary values (not pixel values), the resulting image may not be meaningful visually but could be used to inspect patterns or distribution in the output values.
"""

x = train_images[0:25,:,:]/255.0

x.shape

x = x.reshape(25,784)

x.shape

x  = x.T

x.shape

y = m@x

y.shape

plt.imshow(y)


# -*- coding: utf-8 -*-
"""Spencer Werhan 24 Lab 5.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1gghl6LHHMpfYnXQrOgqE0fbSE99uM5yv
"""

import matplotlib.pyplot as plt #  widely used for plotting and visualizing data in Python. It can also be used to display images.
from PIL import Image # (Python Imaging Library), now known as Pillow in its maintained version, provides extensive file format support, efficient internal representation, and fairly powerful image processing capabilities.
import imageio.v2 as imageio  # designed for reading and writing images and aims to support a wide range of image formats. It is particularly useful for scientific imaging.

def plot(x):
    fig, ax = plt.subplots()
    im = ax.imshow(x,cmap='gray')   # im.show
    ax.axis('off')
    fig.set_size_inches(20, 20)
    plt.show()

"""Your function plot(x) is set up to display an image array x using Matplotlib, with a grayscale colormap. This function is especially useful for visualizing single-channel (e.g., grayscale) images in a large format, as it sets the figure size to 20x20 inches and removes the axis for a cleaner look. Here's a breakdown of what each line does:

> 1. fig, ax = plt.subplots(): Creates a figure and a set of subplots. In this case, it's just one subplot.

> 2. im = ax.imshow(x, cmap='gray'): Displays the image stored in the array x on the axes. The cmap='gray' parameter specifies that the image should be shown in grayscale.

> 3. ax.axis('off'): Hides the axis around the image, so you don't see the tick marks or labels.

> 4. fig.set_size_inches(20, 20): Sets the size of the figure to 20x20 inches. This can be helpful for making sure that the image is large enough to examine in detail.

> 5. plt.show(): Displays the figure. This command is necessary to actually show the plot when running the code outside of interactive environments like Jupyter notebooks.


"""

im = imageio.imread('https://lospec.com/palette-list/st-64-natural-1x.png')

# Reads the image from the url

plot(im)

# Plots the image using the defined plot function above

im.shape

# 1 row, 64 columns, 3 tensors -> the 3 tensors represent the 3 color channels RGB

plot(im[:,40:41,:])

# im[:,40:41,:]
# The first : indicates plot all rows, even there is only one for this specific image
# 40:41 - plot the 40th column up to but not including the 41st
# Last : plot all tensors or color channels

"""[] Scalar


---


[][]

[]

[] Vectors (diagonal or horizontal)


---


[][][][]

[][][][]

[][][][]

[][][][] Matrix


---


3D Matrix -> Tensor
"""

im[:,40:41,:]

# Prints the color intensity for the image slice chosen in order RGB
# Red 34 Green 122 Blue 46

im = imageio.imread('https://lospec.com/palette-list/waverator-1x.png')

plot(im)

im

# Low intensity (almost black) for all colors in first slice to high intensity (almost white)



import numpy as np
import matplotlib.pyplot as plt

# Binary image
binary_image = np.array([
    [0, 1, 0],
    [1, 1, 1],
    [0, 1, 0]
])

# 0 represents black, 1 represents white

binary_image

# Shows that the variable binary_image returns the array specified

plt.imshow(binary_image, cmap='gray')

# Grayscale image
grayscale_image = np.array([
    [50, 100, 150],
    [200, 255, 200],
    [150, 100, 50]
])
plt.imshow(grayscale_image, cmap='gray', vmin=0, vmax=255)

# Plots grayscale, 0 black, 255 white

# 8 bits = 1 byte
# 0-255 -> due to 8 bits being a byte -> 2**n = 2**8 = 256
2**24

# Grayscale image
grayscale_image = np.array([
    [0.2, 0.4, 0.6],
    [0.8, 1.0, 0.8],
    [0.6, 0.4, 0.2]
])
plt.imshow(grayscale_image, cmap='gray')

# Grayscale but values from 0 to 1 instead of 0-255

# RGB image
rgb_image = np.array([
    [[255, 0, 0], [0, 255, 0], [0, 0, 255]],
    [[255, 255, 0], [0, 255, 255], [255, 0, 255]],
    [[128, 128, 128], [255, 255, 255], [0, 0, 0]]
])

# Each row consist of 3 separate arrays that will be plotted to visually show different colors\

rgb_image

plt.imshow(rgb_image)

# RGB image
rgb_image = np.array([
    [[1, 0, 0], [0, 1, 0], [0, 0, 1]],
    [[1, 1, 0], [0, 1, 1], [1, 0, 1]],
    [[0.5, 0.5, 0.5], [1, 1, 1], [0, 0, 0]]
])

# 0-1 scale color image

plt.imshow(rgb_image)

# RGB image
rgb_image = np.array([
    [[1, 0, 0], [0, 1, 0], [0, 0, 1]],
    [[1, 1, 0], [0, 1, 1], [1, 0, 1]],

])

# This is the top 2 rows of above image

rgb_image

plt.imshow(rgb_image*255)

# Converts image to 255 values
# 0s and 1s can be convenient to represent full or no intensity
# whereas the 0-255 can have varying intensities



x = np.zeros((2,2,3)) # Creates a 2x2 array where each element is a 3-element vector. Initially, all values are 0, so every channel of every pixel is black.
x[:,:,0] = 1          # Start at 1
plt.imshow(x)

x

#import numpy as np
#import matplotlib.pyplot as plt

#x = np.zeros((2,2,3)) # Create a 2x2 image with 3 channels, initialized to zeros
#x[:,:,0] = 1          # Set the red channel to maximum intensity for all pixels

#plt.imshow(x)         # Display the image
#plt.show()            # Make sure the plot is shown

"""You've created a 3D NumPy array x with dimensions (2, 2, 3), initialized with zeros. This array represents a 2x2 image where each pixel has three components (presumably for RGB color channels). By setting x[:,:,0] = 1, you've assigned the value 1 to all elements in the first channel (Red channel, if we assume RGB ordering) of each pixel. This means you're making the entire image red, as the red component is set to maximum intensity (1, on a 0-1 scale), while the green and blue components remain at zero intensity.

When you display this image using plt.imshow(x), you'll see a 2x2 red square, because the red channel is fully activated for all pixels, and the other channels are not activated (both set to 0).

Same principle for below images
"""

x = np.zeros((2,2,3))
x[:,:,1] = 1
plt.imshow(x)

x

x = np.zeros((2,2,3))
x[:,:,2] = 1
plt.imshow(x)

x

x = np.zeros((2,2,3))
x[:,:,0] = 1
x[:,:,1] = 1
plt.imshow(x)

x

x = np.zeros((2,2,3))
x[:,:,1] = 1
x[:,:,2] = 1
plt.imshow(x)

x

x = np.zeros((2,2,3))
x[:,:,0] = 1
x[:,:,2] = 1
plt.imshow(x)

x

x = np.zeros((2,2,3))
x[:,:,0] = 0.5
x[:,:,1] = 0.5
x[:,:,2] = 0.5
plt.imshow(x)

x

x = np.zeros((2,2,3))
x[:,:,0] = 1
x[:,:,1] = 1
x[:,:,2] = 1
plt.imshow(x)

x

x = np.zeros((2,2,3))
x[:,:,0] = 0
x[:,:,1] = 0
x[:,:,2] = 0
plt.imshow(x)

x

"""The above images show how color combinations are displayed through plt.imshow"""



r = np.random.rand()

r



r = np.random.rand()
g = np.random.rand()
b = np.random.rand()


x = np.zeros((2,2,3))

x[:,:,0] = r
x[:,:,1] = g
x[:,:,2] = b


plt.imshow(x)

# Generates a random color

x

for i in range(5):

    z = np.ones((10,10,3))

    r = np.random.rand()
    g = np.random.rand()
    b = np.random.rand()

    print(r,g,b)

    z[:,:,0] = r
    z[:,:,1] = g
    z[:,:,2] = b

    plt.imshow(z);
    plt.show()

    # Generates 5 random colors





for i in range(5):

    z1 = np.ones((10,10,3)) # 10 pixels x 10 pixels x 3 color channels
    z2 = np.ones((10,10,3))

    r = np.random.rand()
    g = np.random.rand()
    b = np.random.rand()

    z1[:,:,0] = r
    z1[:,:,1] = g
    z1[:,:,2] = b

    z2[:,:,0] = 1-r
    z2[:,:,1] = 1-g
    z2[:,:,2] = 1-b

    z3 = np.hstack((z1,z2)) # Concatenate (sp?)

    plt.imshow(z3);
    plt.show()

    # Generates 2 random colors in a 10x10 pixel in z1 and z2
    # Loops the process 5 times and

"""The code you've provided generates a pair of 10x10 pixel images with complementary colors for each iteration of the loop, which runs for a total of 5 iterations. Each image (z1 and z2) is initially filled with ones, meaning they start as white. Random color values are generated for the red, green, and blue channels and assigned to z1. The complementary color for z2 is calculated by subtracting the RGB values from 1, which essentially inverts the colors. These two images are then horizontally concatenated using np.hstack() to form z3, and the resulting image is displayed.

Here's a step-by-step explanation:

Loop: Iterates 5 times, creating a new pair of images on each iteration.

Image Initialization: Two 10x10 pixel images (z1 and z2) are created, each filled with ones, thus starting as white in all pixels.

Color Generation: Random values for red, green, and blue are generated and set for z1, resulting in a unique color for each iteration.

Complementary Color: For z2, the complementary colors are calculated by subtracting the RGB values of z1 from 1. This effectively creates the opposite color on the RGB spectrum.

Concatenation: The two images are horizontally concatenated using np.hstack((z1, z2)), creating a 10x20 pixel image (z3) that shows the original and its complementary color side by side.

Display: The concatenated image z3 is displayed using plt.imshow(z3), followed by plt.show() to ensure it's shown in each iteration.

The comment at the end of your code mentions "Generates 10 random colors and then stacks them in a 5x2 arrangement," which seems to be a misunderstanding of what the code does. Instead, the code generates 5 pairs of complementary colors, each displayed in a 10x20 pixel arrangement (due to the horizontal stacking of two 10x10 images). Each iteration displays one pair of these colors, resulting in 5 separate images shown one after the other, not a single 5x2 arrangement of different colors.

The use of np.hstack() to concatenate z1 and z2 side by side is correctly described as horizontal concatenation, which is indeed what "concatenate" refers to in this context.
"""



z1 = np.ones((10,10,3))
z1[:,:,0] = np.random.rand()
z1[:,:,1] = np.random.rand()
z1[:,:,2] = np.random.rand()

z2 = np.ones((10,10,3))
z2[:,:,0] = np.random.rand()
z2[:,:,1] = np.random.rand()
z2[:,:,2] = np.random.rand()

zavg = (z1+z2)/2

z3 = np.hstack((z1,zavg,z2))

plt.imshow(z3);
plt.show()

"""In the code you've shared, you're creating two 10x10 pixel RGB images (z1 and z2) with random colors for each channel. Each channel of z1 and z2 is filled with a uniform random value between 0 and 1, resulting in two uniformly colored squares with different random colors.

You then calculate the average of these two images, zavg, which is done by element-wise addition of z1 and z2 followed by division by 2. This operation blends the colors of z1 and z2, creating a new image that is the average color of the two.

Finally, you horizontally stack these three images (z1, zavg, z2) using np.hstack() to create a single image array z3 that shows the progression from the color of z1 to the color of z2, with the averaged color in between. This results in a visual transition effect between the two randomly chosen colors.

The plt.imshow(z3) command then displays this concatenated image, showing the two original colors and their average in the middle, allowing you to see the blending effect of averaging the colors.

The use of plt.show() ensures that the plot is displayed, which is particularly necessary when running Python scripts outside of interactive environments like Jupyter notebooks.
"""



z1 = np.ones((10,10,3))
z1[:,:,0] = np.random.rand()
z1[:,:,1] = np.random.rand()
z1[:,:,2] = np.random.rand()

z2 = np.ones((10,10,3))
z2[:,:,0] = np.random.rand()
z2[:,:,1] = np.random.rand()
z2[:,:,2] = np.random.rand()

zavg = (z1+z2)/2

z1a = (z1+zavg)/2
z2a = (z2+zavg)/2

z3 = np.hstack((z1,z1a,zavg,z2a,z2))

plt.imshow(z3);
plt.show()

"""In this updated code, you further refine the approach to blending two randomly colored 10x10 pixel images (z1 and z2) by introducing intermediate steps (z1a and z2a). Here's the breakdown of the process:

Create initial images:

Two images, z1 and z2, are initialized as white (all pixels have values [1, 1, 1]).
Random colors are assigned to each image by setting the entire red, green, and blue channels to random values. This results in z1 and z2 each being a uniform color, but different from each other.
Calculate the average color (zavg):

The average color image, zavg, is computed by averaging z1 and z2. This produces an image that is a blend of the two initial images' colors.
Create additional intermediate images:

z1a is calculated as the average between z1 and zavg, creating an intermediate blend closer to z1's color.
Similarly, z2a is the average between z2 and zavg, yielding an intermediate blend closer to z2's color.
Concatenate all images:

The final image, z3, is constructed by horizontally stacking z1, z1a, zavg, z2a, and z2. This creates a gradient effect from z1's color to z2's color, with smoothly transitioning intermediate colors (z1a, zavg, z2a) in between.
Display the image:

The plt.imshow(z3) command displays the concatenated image, showcasing a smooth color transition across the 5 sections from the color of z1 to the color of z2 through the intermediate blends.
This method visually demonstrates a gradient effect between two randomly chosen colors, illustrating a simple yet effective way to create and display a color gradient with Python using NumPy and Matplotlib.
"""





for i in range(100):

    z1 = np.ones((10,10,3))
    z1[:,:,0] = np.random.rand()
    z1[:,:,1] = np.random.rand()
    z1[:,:,2] = np.random.rand()

    z2 = np.ones((10,10,3))
    z2[:,:,0] = np.random.rand()
    z2[:,:,1] = np.random.rand()
    z2[:,:,2] = np.random.rand()

    zavg = (z1+z2)/2

    z1a = (z1+zavg)/2
    z2a = (z2+zavg)/2

    z3 = np.hstack((z1,z1a,zavg,z2a,z2))

    plt.imshow(z3);
    plt.show()

"""The above code repeats the double above process 100 times"""







"""The Python code below defines two functions for generating a visualization of the blending process between two randomly chosen colors and their recursive averages over a specified number of passes.

recursive_average Function

Purpose: This function takes a list of color arrays (images) and computes their recursive averages. For each pair of subsequent colors in the list, it calculates the average color and inserts this average back into the list, effectively smoothing the transition between the original colors.

Process: It starts with the first color and then iteratively averages each subsequent color with the last computed average, extending the list with each new average and the next original color.
generate_recursive_colors_v2 Function

Purpose: This function creates a visualization showing the blending process between two endpoint colors through recursive averaging. It demonstrates how blending evolves with a specified number of recursive passes.

Process:

Initially, two random colors are generated as 10x10 pixel images.
The recursive_average function is applied multiple times (as specified by the passes parameter) to these colors to generate a sequence of averaged colors.
The resulting colors are then horizontally concatenated to form a single image, which visualizes the blending process.

Visualization Loop

The loop at the end of the script generates and displays these visualizations for a range of passes from 0 to 4. With each iteration, the number of colors (and thus, the width of the resulting image) increases as the recursive averaging introduces more intermediate steps between the original two colors.

Expected Output
For each pass i:

Pass 0: You will see two random colors side by side.

Pass 1: The two original colors plus one average color in between.

Each subsequent pass: The number of colors displayed increases as more averages are introduced, showing a more gradual transition from one endpoint color to the other.

This approach effectively visualizes how recursive averaging can be used to smoothly blend between colors, with the complexity of the blend increasing with each additional pass. The visualizations are displayed without axes for a cleaner look, and plt.tight_layout() is used to ensure the plots are neatly arranged without unnecessary padding around the edges.
"""

import numpy as np
import matplotlib.pyplot as plt

def recursive_average(colors):
    """
    Compute the recursive average of the given list of colors.

    Parameters:
    - colors: List of color arrays

    Returns:
    - A new list of color arrays containing the recursive averages.
    """
    new_colors = [colors[0]]
    for i in range(1, len(colors)):
        avg_color = (colors[i] + new_colors[-1]) / 2.0
        new_colors.extend([avg_color, colors[i]])
    return new_colors

def generate_recursive_colors_v2(passes):
    """
    Generate a visualization of 2 random colors and their recursive averages for a number of passes.

    Parameters:
    - passes: Number of times to apply the recursive averaging process

    Returns:
    - An image showing the 2 endpoint colors and their recursive averages.
    """
    # Start with 2 random colors
    colors = [np.ones((10,10,3)) for _ in range(2)]
    for color in colors:
        color[:,:,0] = np.random.rand()
        color[:,:,1] = np.random.rand()
        color[:,:,2] = np.random.rand()

    # Apply the recursive averaging for the specified number of passes
    for _ in range(passes):
        colors = recursive_average(colors)

    # Horizontally stack the colors
    result = np.hstack(colors)

    return result

for i in range(5):
    img = generate_recursive_colors_v2(i)
    plt.imshow(img)
    plt.axis('off')
    plt.tight_layout()
    plt.show()





"""The updated Python code efficiently demonstrates a more advanced approach to visualizing the effect of recursive averaging on a pair of initial colors across multiple passes. This version incorporates the capability to specify the initial colors and dynamically generate the visualization for different numbers of recursive passes, all displayed side by side for easy comparison.

Key Components of the Updated Code:

Initial Color Setup: Two initial colors are generated randomly, with each color being a 10x10 pixel array. These colors serve as the starting point for the recursive averaging process.

Recursive Averaging Function: The recursive_average function remains unchanged, methodically blending a list of color arrays by calculating the average between each pair of colors and expanding the list with these averages.

Visualization for Multiple Passes: The generate_recursive_colors_v2 function, now modified to accept initial_colors as an argument, applies the recursive averaging process a specified number of times (passes). The function returns a horizontally concatenated image array of the resulting color sequence.

Efficient Visualization Generation: Instead of displaying each image in a separate plot within a loop, the code generates a list of images (imgs) corresponding to a series of specified passes (passes_values). Each image showcases the outcome of the recursive averaging process for a given number of passes.

Subplot Visualization: The images are displayed side by side in a single figure with multiple subplots (fig, axs = plt.subplots(...)), each labeled with the number of passes it represents. This layout provides a clear, comparative view of how the number of passes affects the blending transition between the initial colors.

Result:
Upon execution, this script generates a single figure with multiple subplots, each displaying the result of the recursive averaging process for 0 to 4 passes. As the number of passes increases, the transitions between the initial colors become progressively smoother, illustrating the gradual blending effect achieved through recursive averaging.

This visualization technique not only demonstrates the concept of color blending and recursive function application in image processing but also showcases how to use Matplotlib for complex visual data representation, combining both computational and graphical approaches to illustrate concepts effectively.
"""

import numpy as np
import matplotlib.pyplot as plt

def recursive_average(colors):

    new_colors = [colors[0]]
    for i in range(1, len(colors)):
        avg_color = (colors[i] + new_colors[-1]) / 2.0
        new_colors.extend([avg_color, colors[i]])
    return new_colors

def generate_recursive_colors_v2(passes, initial_colors):

    colors = initial_colors.copy()

    for _ in range(passes):
        colors = recursive_average(colors)

    result = np.hstack(colors)

    return result

initial_colors = [np.ones((10, 10, 3)) for _ in range(2)]
for color in initial_colors:
    color[:,:,0] = np.random.rand()
    color[:,:,1] = np.random.rand()
    color[:,:,2] = np.random.rand()

passes_values = [0,1,2,3,4]
imgs = [generate_recursive_colors_v2(p, initial_colors) for p in passes_values]

fig, axs = plt.subplots(1, len(passes_values), figsize=(15, 5))

for ax, img, p in zip(axs, imgs, passes_values):
    ax.imshow(img)
    ax.axis('off')
    ax.set_title(f'Passes={p}')

plt.tight_layout()
plt.show()

"""https://lospec.com/palette-list"""





"""The function get_colors_lospec you've created is designed to read an image from a specified URL, which is expected to be a palette image from Lospec or a similar source. This image should contain a row of color swatches representing different colors in the palette. The function then processes this image to create and return a custom Matplotlib colormap based on the colors extracted from the image. Here's a breakdown of how it works:

Image Reading: The imageio.imread(url) function is used to read the image from the given URL. This image is expected to be in a format where each color in the palette is represented as a distinct column in the first row of the image.

Color Extraction: The colors are extracted from the first row of the image and normalized to the range [0, 1] by dividing by 255, since imageio.imread reads the image into an array with color values in the range [0, 255].

Color Dictionary Construction: A color dictionary (cdict) for the red, green, and blue components is constructed. For each component, a list of tuples is created where each tuple contains:

A position in the colormap (ranging linearly from 0 to 1, corresponding to the position of the color in the original image).
The intensity of the color component at that position (twice, once for the start and once for the end of the segment in the colormap).
Colormap Creation: A LinearSegmentedColormap is created from the color dictionary using mcolors.LinearSegmentedColormap('my_cmp', segmentdata=cdict, N=256). This colormap can then be used in Matplotlib plots to apply the color palette derived from the image.

This function allows for dynamic creation of colormaps from any palette image, enabling customization and thematic consistency in data visualizations according to specific color schemes.

Important Note:
This function assumes the input image has a specific format: a single row of color swatches representing the palette.
The function won't work as expected if the URL fetching is attempted in an environment without internet access or if the security policies block the fetching of images from URLs.
The normalization step (im/255) assumes the input image uses 8-bit color depth for each channel. This is typical, but it's good to be aware of in case you encounter images with different color depths.
To use this function effectively, ensure that the environment where you're executing the code has access to the internet (if fetching images online) and that Matplotlib and other dependencies are properly installed and imported.
"""

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.colors as mcolors
import matplotlib
import imageio.v2 as imageio
from PIL import Image

def get_colors_lospec(url):
    im = imageio.imread(url)
    rgb_list = (im/255)[0,:,0:3]
    float_list = list(np.linspace(0,1,len(rgb_list)))
    cdict = dict()
    for num, col in enumerate(['red', 'green', 'blue']):
        col_list = [[float_list[i], rgb_list[i][num], rgb_list[i][num]] for i in range(len(float_list))]
        cdict[col] = col_list
    cmp = mcolors.LinearSegmentedColormap('my_cmp', segmentdata=cdict, N=256)
    return cmp

url = 'https://lospec.com/palette-list/agb-32x.png'
im = imageio.imread(url)
plt.imshow(im);

url = 'https://lospec.com/palette-list/agb-1x.png'
im = imageio.imread(url)
plt.imshow(im);

url = 'https://lospec.com/palette-list/moondrom-1x.png'
im = imageio.imread(url)
plt.imshow(im);

# Different sources to show different url images

z = np.random.randint(0,256,size=(10,10))

# 2D NumPy array z with shape (10, 10), filled with random integers in the range [0, 255).

z

plt.imshow(z)

plt.imshow(z, cmap=get_colors_lospec(url))
plt.colorbar();





"""You've created a grid of points using np.mgrid and then calculated the value of z as the Euclidean distance from each point to the origin, effectively generating a 2D radial distance field. The expression np.sqrt(x**2 + y**2) computes the distance of each point (x, y) in the grid from the origin (0, 0), producing a circular pattern that represents the magnitude of the distance at each point in the grid.

The np.mgrid function creates two 2D arrays, x and y, which represent the x and y coordinates of a grid that spans from -5 to 5 in both directions, with a step size of 0.05. This results in a finely sampled grid that covers the specified range with high resolution.

Here's how you can visualize the computed z values, which will show a radial gradient from the center outward:


```
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

# Compute the grid and the z values
x, y = np.mgrid[-5:5:0.05, -5:5:0.05]
z = np.sqrt(x**2 + y**2)

# Plot using matplotlib
fig = plt.figure(figsize=(8, 6))
ax = fig.add_subplot(111, projection='3d')
surf = ax.plot_surface(x, y, z, cmap='viridis')

# Add a color bar to provide a reference to the z values
fig.colorbar(surf)

# Set labels and title for clarity
ax.set_xlabel('X axis')
ax.set_ylabel('Y axis')
ax.set_zlabel('Z axis')
ax.set_title('Radial Distance from Origin')

plt.show()

```
This code block will generate a 3D surface plot visualizing the radial distance values. The use of a colormap ('viridis' in this case) highlights the variation in distance across the surface, with different colors representing different distances from the origin. The color bar added to the side of the plot provides a reference for interpreting the colors in terms of z values.

"""

x, y = np.mgrid[-5:5:0.05, -5:5:0.05]
z = np.sqrt(x**2 + y**2)

x

# Show x array

y

# Shows y array

z = np.sqrt(x**2 + y**2)

z.shape

plt.imshow(x)

plt.imshow(y)

z

plt.imshow(z, cmap=get_colors_lospec(url));
plt.show()

"""The above section gives shows the indiviudal parts and how they combine to form the radial final image"""



x, y = np.mgrid[-5:5:0.05, -5:5:0.05]

z = np.sin(3*y)

plt.imshow(z, cmap=get_colors_lospec(url));
plt.show()

x, y = np.mgrid[-5:5:0.05, -5:5:0.05]

z = np.sin(3*x)

plt.imshow(z, cmap=get_colors_lospec(url));
plt.show()

x, y = np.mgrid[-5:5:0.05, -5:5:0.05]

z = np.sin(3*y)*np.sin(3*x)

plt.imshow(z, cmap=get_colors_lospec(url));
plt.show()

"""First Block

You create a 2D grid with x and y coordinates using np.mgrid.
You calculate z = np.sin(3*y), which applies a sine wave pattern vertically across the grid because the sine function is applied to the y values.
When visualized with plt.imshow, this will show vertical stripes corresponding to the sine wave's peaks and troughs.

Second Block

Again, a 2D grid is created.
This time, z = np.sin(3*x), applying the sine wave pattern horizontally across the grid because the sine function is applied to the x values.
The visualization will show horizontal stripes.

Third Block

After creating the same 2D grid,
You calculate z = np.sin(3*y)*np.sin(3*x), creating a combination of horizontal and vertical patterns. This results in a grid where the sine wave patterns in both x and y directions are multiplied, creating a more complex pattern of peaks and troughs.
The resulting visualization will have a checkerboard-like pattern with varying intensities, corresponding to the product of the sine functions.

Visualization

Each plt.imshow(z, cmap=get_colors_lospec(url)) call displays the calculated z values using colors from the palette specified by the url. The use of a custom colormap from Lospec allows for unique and visually appealing representations of these mathematical functions.

Expected Outcome
First and Second Blocks: Distinct vertical or horizontal bands representing the sine wave's amplitude variations across the y or x dimensions, respectively.
Third Block: A complex pattern where the effects of the sine functions in both dimensions are combined, likely resulting in a pattern that looks like waves intersecting each other.
"""



import matplotlib.pyplot as plt
import imageio
from PIL import Image

def plot(x):
    fig, ax = plt.subplots()
    im = ax.imshow(x,cmap='gray')
    ax.axis('off')
    fig.set_size_inches(20, 20)
    plt.show()

im = imageio.imread('https://raw.githubusercontent.com/imageio/imageio-binaries/master/images/imageio_banner.png')

plot(im)

# url = "(image url)"

""" The concept behind the code is to use the imageio.imread function to load an image from a URL and then display it using a custom plot function that sets up a Matplotlib plot without axes and with a specified figure size. This approach is quite useful for displaying images in a clean and focused manner, especially for presentations or analysis where you want to focus solely on the image content without the distraction of axes or labels.


Here's a brief rundown of what each part of your code does:

Imports: Necessary libraries are imported, including matplotlib.pyplot for plotting, imageio for image reading, and PIL.Image (though Image from PIL is imported but not used in your snippet).

plot Function: This function takes an image array x and plots it using Matplotlib. It uses a grayscale colormap (cmap='gray'), but for color images, you might want to remove this argument to preserve the original colors. The axes are turned off for a cleaner look, and the figure size is set to 20x20 inches for a large display.

Image Reading: The imageio.imread function reads an image from the specified URL, which should result in a NumPy array representing the image.

Plotting: Finally, the plot function is called with the image array, displaying the image within a large, axis-free plot.

To display a color image properly, you might want to adjust the plot function to not use the cmap='gray' argument, allowing Matplotlib to render the image in full color.






"""